
./build/boot_STM32_L011D4Px.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000010  08000000  08000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000030  08000010  08000010  00008010  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text.startup 00000194  08000040  08000040  00008040  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000011  080001d4  080001d4  000081d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000085e  00000000  00000000  000081e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002ea  00000000  00000000  00008a43  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000048  00000000  00000000  00008d2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000216  00000000  00000000  00008d75  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000397  00000000  00000000  00008f8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000070  00000000  00000000  00009322  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  00009392  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000074  00000000  00000000  000093c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000033a  00000000  00000000  00009438  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000060  00000000  00000000  00009772  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000010 <Default_Handler>:
{
   main();
}

void __attribute__((naked, noreturn)) Default_Handler(){
    while(1);
 8000010:	e7fe      	b.n	8000010 <Default_Handler>

08000012 <Reset_Handler>:
    &HardFault_Handler
};

void __attribute__((naked, noreturn)) Reset_Handler()
{
   main();
 8000012:	f000 f815 	bl	8000040 <main>
 8000016:	0000      	movs	r0, r0

08000018 <SendData>:
#define ERASE 				(FLASH_PECR_ERASE | FLASH_PECR_PROG)

static void SendData(const uint8_t* data, uint32_t size)
{
	// enable Tx
	UART->CR1 = USART_CR1_TE | USART_CR1_UE;
 8000018:	2209      	movs	r2, #9
 800001a:	4b08      	ldr	r3, [pc, #32]	; (800003c <SendData+0x24>)
 800001c:	1841      	adds	r1, r0, r1
 800001e:	601a      	str	r2, [r3, #0]
	while (size--)
 8000020:	4288      	cmp	r0, r1
 8000022:	d006      	beq.n	8000032 <SendData+0x1a>
	{
		UART->TDR = *(data++);		
 8000024:	7802      	ldrb	r2, [r0, #0]
 8000026:	629a      	str	r2, [r3, #40]	; 0x28
		while(!(UART->ISR & USART_ISR_TXE_Msk));
 8000028:	69da      	ldr	r2, [r3, #28]
 800002a:	0612      	lsls	r2, r2, #24
 800002c:	d5fc      	bpl.n	8000028 <SendData+0x10>
 800002e:	3001      	adds	r0, #1
 8000030:	e7f6      	b.n	8000020 <SendData+0x8>
	}
	
	while(!(UART->ISR & USART_ISR_TC_Msk));
 8000032:	69da      	ldr	r2, [r3, #28]
 8000034:	0652      	lsls	r2, r2, #25
 8000036:	d5fc      	bpl.n	8000032 <SendData+0x1a>
		
	//UART->CR1 = USART_CR1_UE;
}
 8000038:	4770      	bx	lr
 800003a:	46c0      	nop			; (mov r8, r8)
 800003c:	40004800 	.word	0x40004800

Disassembly of section .text.startup:

08000040 <main>:
int main(void)
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 8000040:	23fa      	movs	r3, #250	; 0xfa
    __set_MSP(*(__IO uint32_t*) _FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
}

int main(void)
{	
 8000042:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000044:	4c52      	ldr	r4, [pc, #328]	; (8000190 <main+0x150>)
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 8000046:	031b      	lsls	r3, r3, #12
    __set_MSP(*(__IO uint32_t*) _FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
}

int main(void)
{	
 8000048:	44a5      	add	sp, r4
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 800004a:	4c52      	ldr	r4, [pc, #328]	; (8000194 <main+0x154>)
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 800004c:	22c0      	movs	r2, #192	; 0xc0
int main(void)
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
 800004e:	6063      	str	r3, [r4, #4]
	SysTick->VAL = 0;
 8000050:	2300      	movs	r3, #0
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 8000052:	2705      	movs	r7, #5
{	
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
	SysTick->VAL = 0;
 8000054:	60a3      	str	r3, [r4, #8]
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 8000056:	4b50      	ldr	r3, [pc, #320]	; (8000198 <main+0x158>)
 8000058:	02d2      	lsls	r2, r2, #11
	
// BR = 9600 !!!!!	
	// SysTick
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 800005a:	6027      	str	r7, [r4, #0]
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
 800005c:	639a      	str	r2, [r3, #56]	; 0x38
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
 800005e:	2201      	movs	r2, #1
	UART->CR3 = USART_CR3_HDSEL;
 8000060:	2008      	movs	r0, #8
	SysTick->LOAD = ANSWER_WAIT_MS * SYS_CLK_FREQ_KHZ;
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
 8000062:	62da      	str	r2, [r3, #44]	; 0x2c
	UART->CR3 = USART_CR3_HDSEL;
 8000064:	4d4d      	ldr	r5, [pc, #308]	; (800019c <main+0x15c>)
	UART->BRR = 0xD055;
 8000066:	4b4e      	ldr	r3, [pc, #312]	; (80001a0 <main+0x160>)
	// GPIO	
	UART_PORT->OTYPER = GPIO_OTYPER_OT_1; // OpenDrain
 8000068:	22a0      	movs	r2, #160	; 0xa0
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
	// UART
	RCC->APB1ENR = RCC_APB1ENR_LPUART1EN | RCC_APB1ENR_USART2EN; 
	RCC->IOPENR = RCC_IOPENR_GPIOAEN;
	UART->CR3 = USART_CR3_HDSEL;
 800006a:	60a8      	str	r0, [r5, #8]
	UART->BRR = 0xD055;
 800006c:	60eb      	str	r3, [r5, #12]
	// GPIO	
	UART_PORT->OTYPER = GPIO_OTYPER_OT_1; // OpenDrain
 800006e:	2302      	movs	r3, #2
 8000070:	05d2      	lsls	r2, r2, #23
 8000072:	6053      	str	r3, [r2, #4]
	UART_PORT->PUPDR |= GPIO_PUPDR_PUPD1_0;		
 8000074:	68d1      	ldr	r1, [r2, #12]
 8000076:	18db      	adds	r3, r3, r3
 8000078:	4319      	orrs	r1, r3
 800007a:	60d1      	str	r1, [r2, #12]
	UART_PORT->AFR[0] = 6 << GPIO_AFRL_AFSEL1_Pos;
	UART_PORT->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE1_Msk) | GPIO_MODER_MODE1_1; 
 800007c:	210c      	movs	r1, #12
	UART->CR3 = USART_CR3_HDSEL;
	UART->BRR = 0xD055;
	// GPIO	
	UART_PORT->OTYPER = GPIO_OTYPER_OT_1; // OpenDrain
	UART_PORT->PUPDR |= GPIO_PUPDR_PUPD1_0;		
	UART_PORT->AFR[0] = 6 << GPIO_AFRL_AFSEL1_Pos;
 800007e:	335c      	adds	r3, #92	; 0x5c
 8000080:	6213      	str	r3, [r2, #32]
	UART_PORT->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE1_Msk) | GPIO_MODER_MODE1_1; 
 8000082:	6813      	ldr	r3, [r2, #0]
	//
	uint32_t buff32[(1<<_PAGE_SIZE_POW) + 5]; // потому-что памяти завались....
	uint8_t *buff = (uint8_t *)buff32;
	static const uint8_t firstPacket[] = {0x06, 0x47, _BOOT_VER, _HW_TYPE, _HW_VER, _PAGE_SIZE_POW, _PAGES_FOR_WRITE >> 8, _PAGES_FOR_WRITE,
										  0x06^ 0x47 ^_BOOT_VER ^_HW_TYPE ^_HW_VER ^_PAGE_SIZE_POW^(_PAGES_FOR_WRITE >> 8)^_PAGES_FOR_WRITE};
	SendData((void*)firstPacket, sizeof(firstPacket));
 8000084:	4e47      	ldr	r6, [pc, #284]	; (80001a4 <main+0x164>)
	UART->BRR = 0xD055;
	// GPIO	
	UART_PORT->OTYPER = GPIO_OTYPER_OT_1; // OpenDrain
	UART_PORT->PUPDR |= GPIO_PUPDR_PUPD1_0;		
	UART_PORT->AFR[0] = 6 << GPIO_AFRL_AFSEL1_Pos;
	UART_PORT->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE1_Msk) | GPIO_MODER_MODE1_1; 
 8000086:	438b      	bics	r3, r1
 8000088:	4303      	orrs	r3, r0
 800008a:	6013      	str	r3, [r2, #0]
	//
	uint32_t buff32[(1<<_PAGE_SIZE_POW) + 5]; // потому-что памяти завались....
	uint8_t *buff = (uint8_t *)buff32;
	static const uint8_t firstPacket[] = {0x06, 0x47, _BOOT_VER, _HW_TYPE, _HW_VER, _PAGE_SIZE_POW, _PAGES_FOR_WRITE >> 8, _PAGES_FOR_WRITE,
										  0x06^ 0x47 ^_BOOT_VER ^_HW_TYPE ^_HW_VER ^_PAGE_SIZE_POW^(_PAGES_FOR_WRITE >> 8)^_PAGES_FOR_WRITE};
	SendData((void*)firstPacket, sizeof(firstPacket));
 800008c:	1c30      	adds	r0, r6, #0
 800008e:	3903      	subs	r1, #3
 8000090:	f7ff ffc2 	bl	8000018 <SendData>
	
	UART->CR1 = USART_CR1_RE | USART_CR1_UE;
 8000094:	602f      	str	r7, [r5, #0]
 8000096:	9601      	str	r6, [sp, #4]
	
	while(!(UART->ISR & USART_ISR_RXNE_Msk))
 8000098:	69eb      	ldr	r3, [r5, #28]
 800009a:	069b      	lsls	r3, r3, #26
 800009c:	d40c      	bmi.n	80000b8 <main+0x78>
	{
		if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
 800009e:	6823      	ldr	r3, [r4, #0]
 80000a0:	03db      	lsls	r3, r3, #15
 80000a2:	d5f9      	bpl.n	8000098 <main+0x58>
    uint32_t app_jump_address;
	
    typedef void(*pFunction)(void);//объявляем пользовательский тип
    pFunction Jump_To_Application;//и создаём переменную этого типа
		
		SCB->VTOR = _FW_PAGE_START;
 80000a4:	4b40      	ldr	r3, [pc, #256]	; (80001a8 <main+0x168>)
 80000a6:	4a41      	ldr	r2, [pc, #260]	; (80001ac <main+0x16c>)
 80000a8:	6093      	str	r3, [r2, #8]
	
    app_jump_address = *( uint32_t*) (_FW_PAGE_START + 4);    //извлекаем адрес перехода из вектора Reset
    Jump_To_Application = (pFunction)app_jump_address;            //приводим его к пользовательскому типу
    __set_MSP(*(__IO uint32_t*) _FW_PAGE_START);          //устанавливаем SP приложения                                           
 80000aa:	681b      	ldr	r3, [r3, #0]
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 80000ac:	f383 8808 	msr	MSP, r3
    typedef void(*pFunction)(void);//объявляем пользовательский тип
    pFunction Jump_To_Application;//и создаём переменную этого типа
		
		SCB->VTOR = _FW_PAGE_START;
	
    app_jump_address = *( uint32_t*) (_FW_PAGE_START + 4);    //извлекаем адрес перехода из вектора Reset
 80000b0:	4b3f      	ldr	r3, [pc, #252]	; (80001b0 <main+0x170>)
    Jump_To_Application = (pFunction)app_jump_address;            //приводим его к пользовательскому типу
    __set_MSP(*(__IO uint32_t*) _FW_PAGE_START);          //устанавливаем SP приложения                                           
    Jump_To_Application();		                        //запускаем приложение	
 80000b2:	681b      	ldr	r3, [r3, #0]
 80000b4:	4798      	blx	r3
 80000b6:	e7ef      	b.n	8000098 <main+0x58>
	{
		if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
			Go_To_User_App();
	}
	
	FLASH->PEKEYR =  0x89ABCDEF;
 80000b8:	4c3e      	ldr	r4, [pc, #248]	; (80001b4 <main+0x174>)
 80000ba:	4b3f      	ldr	r3, [pc, #252]	; (80001b8 <main+0x178>)
 80000bc:	60e3      	str	r3, [r4, #12]
	FLASH->PEKEYR =  0x02030405;
 80000be:	4b3f      	ldr	r3, [pc, #252]	; (80001bc <main+0x17c>)
 80000c0:	60e3      	str	r3, [r4, #12]
	FLASH->PRGKEYR = 0x8C9DAEBF;
 80000c2:	4b3f      	ldr	r3, [pc, #252]	; (80001c0 <main+0x180>)
 80000c4:	6123      	str	r3, [r4, #16]
	FLASH->PRGKEYR = 0x13141516;
 80000c6:	4b3f      	ldr	r3, [pc, #252]	; (80001c4 <main+0x184>)
 80000c8:	6123      	str	r3, [r4, #16]
	//UART->CR1 = USART_CR1_UE;
}

static uint16_t ReceiveData(uint8_t *data)
{	
	UART->CR1 = USART_CR1_RE | USART_CR1_UE;
 80000ca:	2305      	movs	r3, #5
 80000cc:	602b      	str	r3, [r5, #0]
	while(!(UART->ISR & USART_ISR_RXNE_Msk));
 80000ce:	69eb      	ldr	r3, [r5, #28]
 80000d0:	069b      	lsls	r3, r3, #26
 80000d2:	d5fc      	bpl.n	80000ce <main+0x8e>
	*data = UART->RDR;
 80000d4:	4b31      	ldr	r3, [pc, #196]	; (800019c <main+0x15c>)
 80000d6:	a803      	add	r0, sp, #12
 80000d8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	
	uint16_t size = (*data == 0xFF) ? (1<<_PAGE_SIZE_POW) + 2 : *data;
 80000da:	2382      	movs	r3, #130	; 0x82

static uint16_t ReceiveData(uint8_t *data)
{	
	UART->CR1 = USART_CR1_RE | USART_CR1_UE;
	while(!(UART->ISR & USART_ISR_RXNE_Msk));
	*data = UART->RDR;
 80000dc:	b2d2      	uxtb	r2, r2
 80000de:	7002      	strb	r2, [r0, #0]
	
	uint16_t size = (*data == 0xFF) ? (1<<_PAGE_SIZE_POW) + 2 : *data;
 80000e0:	2aff      	cmp	r2, #255	; 0xff
 80000e2:	d000      	beq.n	80000e6 <main+0xa6>
 80000e4:	b293      	uxth	r3, r2
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
	
	for(int i=1; i<size; i++)
 80000e6:	2201      	movs	r2, #1
	while(!(UART->ISR & USART_ISR_RXNE_Msk));
	*data = UART->RDR;
	
	uint16_t size = (*data == 0xFF) ? (1<<_PAGE_SIZE_POW) + 2 : *data;
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
 80000e8:	3303      	adds	r3, #3
	
	for(int i=1; i<size; i++)
 80000ea:	429a      	cmp	r2, r3
 80000ec:	da07      	bge.n	80000fe <main+0xbe>
	{
		while(!(UART->ISR & USART_ISR_RXNE_Msk)); 
 80000ee:	69e9      	ldr	r1, [r5, #28]
 80000f0:	0689      	lsls	r1, r1, #26
 80000f2:	d5fc      	bpl.n	80000ee <main+0xae>
		*(data++) = UART->RDR;
 80000f4:	4929      	ldr	r1, [pc, #164]	; (800019c <main+0x15c>)
 80000f6:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80000f8:	5481      	strb	r1, [r0, r2]
	
	uint16_t size = (*data == 0xFF) ? (1<<_PAGE_SIZE_POW) + 2 : *data;
	data++;
	size += 3;	// sizeByte typeByte .. CheckSummByte
	
	for(int i=1; i<size; i++)
 80000fa:	3201      	adds	r2, #1
 80000fc:	e7f5      	b.n	80000ea <main+0xaa>
 80000fe:	2200      	movs	r2, #0
 8000100:	1c11      	adds	r1, r2, #0
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
			xor ^= buff[i];
 8000102:	5c87      	ldrb	r7, [r0, r2]
	static const uint8_t errType[] = {1, 0x10, 2, 0x10 ^ 2 };
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
 8000104:	3201      	adds	r2, #1
			xor ^= buff[i];
 8000106:	4079      	eors	r1, r7
	static const uint8_t errType[] = {1, 0x10, 2, 0x10 ^ 2 };
	while (1)
	{
		size = ReceiveData(buff);
		xor = 0;
		for (i=0; i<size; i++)
 8000108:	429a      	cmp	r2, r3
 800010a:	dbfa      	blt.n	8000102 <main+0xc2>
			xor ^= buff[i];
		if (xor)
 800010c:	2900      	cmp	r1, #0
 800010e:	d002      	beq.n	8000116 <main+0xd6>
		{					
			SendData(errCS, sizeof(errCS));
 8000110:	9801      	ldr	r0, [sp, #4]
 8000112:	3009      	adds	r0, #9
 8000114:	e00f      	b.n	8000136 <main+0xf6>
			continue;
		}
		
		if (buff[1] == 0xC7)
 8000116:	7843      	ldrb	r3, [r0, #1]
 8000118:	2bc7      	cmp	r3, #199	; 0xc7
 800011a:	d108      	bne.n	800012e <main+0xee>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800011c:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000120:	4a29      	ldr	r2, [pc, #164]	; (80001c8 <main+0x188>)
 8000122:	4b22      	ldr	r3, [pc, #136]	; (80001ac <main+0x16c>)
 8000124:	60da      	str	r2, [r3, #12]
 8000126:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800012a:	46c0      	nop			; (mov r8, r8)
 800012c:	e7fd      	b.n	800012a <main+0xea>
			NVIC_SystemReset();
	
		if (buff[1] != 0x88)
 800012e:	2b88      	cmp	r3, #136	; 0x88
 8000130:	d003      	beq.n	800013a <main+0xfa>
		{			
			SendData(errType, sizeof(errType));
 8000132:	9801      	ldr	r0, [sp, #4]
 8000134:	300d      	adds	r0, #13
 8000136:	2104      	movs	r1, #4
 8000138:	e027      	b.n	800018a <main+0x14a>
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 800013a:	2782      	movs	r7, #130	; 0x82
		{			
			SendData(errType, sizeof(errType));
			continue;
		}
	
		uint32_t addr = _FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _PAGE_SIZE_POW);
 800013c:	7883      	ldrb	r3, [r0, #2]
 800013e:	78c2      	ldrb	r2, [r0, #3]
 8000140:	021b      	lsls	r3, r3, #8
 8000142:	189b      	adds	r3, r3, r2
 8000144:	4a18      	ldr	r2, [pc, #96]	; (80001a8 <main+0x168>)
 8000146:	01db      	lsls	r3, r3, #7
 8000148:	189a      	adds	r2, r3, r2
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 800014a:	00bf      	lsls	r7, r7, #2
 800014c:	6067      	str	r7, [r4, #4]
	*(uint32_t *)addr = data;
 800014e:	6011      	str	r1, [r2, #0]
	while ( (FLASH->SR & FLASH_SR_BSY) );
 8000150:	69a1      	ldr	r1, [r4, #24]
 8000152:	07c9      	lsls	r1, r1, #31
 8000154:	d4fc      	bmi.n	8000150 <main+0x110>
 8000156:	491d      	ldr	r1, [pc, #116]	; (80001cc <main+0x18c>)
 8000158:	185f      	adds	r7, r3, r1
 800015a:	4e1d      	ldr	r6, [pc, #116]	; (80001d0 <main+0x190>)
 800015c:	1ad1      	subs	r1, r2, r3
 800015e:	1989      	adds	r1, r1, r6
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 8000160:	2600      	movs	r6, #0
		uint32_t addr = _FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _PAGE_SIZE_POW);
		FlashWriteWord(addr, 0, ERASE);
		uint32_t word;
		for(i=0; i < (1<<_PAGE_SIZE_POW); i+=4)
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
 8000162:	5841      	ldr	r1, [r0, r1]
	return size;
}

static void FlashWriteWord(uint32_t addr, uint32_t data, uint32_t isErase) // 0 или ERASE
{		
	FLASH->PECR = isErase;
 8000164:	6066      	str	r6, [r4, #4]
	*(uint32_t *)addr = data;
 8000166:	6011      	str	r1, [r2, #0]
	while ( (FLASH->SR & FLASH_SR_BSY) );
 8000168:	69a1      	ldr	r1, [r4, #24]
 800016a:	07c9      	lsls	r1, r1, #31
 800016c:	d4fc      	bmi.n	8000168 <main+0x128>
		uint32_t word;
		for(i=0; i < (1<<_PAGE_SIZE_POW); i+=4)
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
			FlashWriteWord(addr, word, 0);
			addr += 4;
 800016e:	3204      	adds	r2, #4
		}
	
		uint32_t addr = _FW_PAGE_START + (((buff[2]<<8) + buff[3]) << _PAGE_SIZE_POW);
		FlashWriteWord(addr, 0, ERASE);
		uint32_t word;
		for(i=0; i < (1<<_PAGE_SIZE_POW); i+=4)
 8000170:	42ba      	cmp	r2, r7
 8000172:	d1f2      	bne.n	800015a <main+0x11a>
		{			
			word = /*__REV*/(*(uint32_t*)&buff[4+i]);
			FlashWriteWord(addr, word, 0);
			addr += 4;
		}	
		buff[0] = 2;
 8000174:	2302      	movs	r3, #2
 8000176:	7003      	strb	r3, [r0, #0]
		buff[1] = 0x08;
 8000178:	3306      	adds	r3, #6
 800017a:	7882      	ldrb	r2, [r0, #2]
 800017c:	7043      	strb	r3, [r0, #1]
 800017e:	78c3      	ldrb	r3, [r0, #3]
		buff[4] = buff[0] ^ buff[1] ^ buff[2] ^ buff[3];
		SendData(buff, 5);
 8000180:	2105      	movs	r1, #5
 8000182:	4053      	eors	r3, r2
			FlashWriteWord(addr, word, 0);
			addr += 4;
		}	
		buff[0] = 2;
		buff[1] = 0x08;
		buff[4] = buff[0] ^ buff[1] ^ buff[2] ^ buff[3];
 8000184:	220a      	movs	r2, #10
 8000186:	4053      	eors	r3, r2
 8000188:	7103      	strb	r3, [r0, #4]
		SendData(buff, 5);
 800018a:	f7ff ff45 	bl	8000018 <SendData>
 800018e:	e79c      	b.n	80000ca <main+0x8a>
 8000190:	fffffddc 	.word	0xfffffddc
 8000194:	e000e010 	.word	0xe000e010
 8000198:	40021000 	.word	0x40021000
 800019c:	40004800 	.word	0x40004800
 80001a0:	0000d055 	.word	0x0000d055
 80001a4:	080001d4 	.word	0x080001d4
 80001a8:	08000200 	.word	0x08000200
 80001ac:	e000ed00 	.word	0xe000ed00
 80001b0:	08000204 	.word	0x08000204
 80001b4:	40022000 	.word	0x40022000
 80001b8:	89abcdef 	.word	0x89abcdef
 80001bc:	02030405 	.word	0x02030405
 80001c0:	8c9daebf 	.word	0x8c9daebf
 80001c4:	13141516 	.word	0x13141516
 80001c8:	05fa0004 	.word	0x05fa0004
 80001cc:	08000280 	.word	0x08000280
 80001d0:	f7fffe04 	.word	0xf7fffe04
